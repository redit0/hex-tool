// Prints usage and flag descriptions for the tree utility.
// @return {none}
treeHelp = function(self)
    text = g.const.ni + g.l3("Usage:","u") + g.const.ni
    text = text + g.g2(self.name) + g.b3(" {path}") + g.l2(" Displays the file system contents in a tree view starting from the specified path, or the root if a path is not specified") + g.const.ni
    text = text + g.g2(self.name) + g.b3(" [-h/help]") + g.l2(" Displays this help text") + g.const.nl

    print(text)
end function

// Displays the filesystem of the current context in a tree view with permissions, owner,
// and group columns.  Optionally starts from a specified path; defaults to root.
// Files are color-coded by type and sensitivity.
// @param {list<string>|null} args - Optional: [path] to start from, or null for root.
// @return {none}
tree = function(args = null)
    // Wraps a permissions string in a color-coded bracket.  Fully locked-down strings
    // are dimmed; all others are styled with s2.
    // @return {string} - The formatted permissions label.
    string.formatPermissions = function
        if not self isa string then
            print(g.error("Invalid type: " + typeof(self)))
            return null
        end if

        if self == "d---------" or self == "----------" then
            return g.l2("[" + self + "]")
        else
            return g.s2("[" + self + "]")
        end if
    end function

    // Wraps a username string in a color-coded bracket.  "root" is dimmed; others use s2.
    // @return {string} - The formatted username label.
    string.formatUsername = function
        if not self isa string then
            return self
        end if

        if self == "root" then return g.l2("[" + self + "]") else return g.s2("[" + self + "]")
    end function

    // Returns a sortable key string for a file object by stripping non-alphanumeric
    // characters from its path.
    // @return {string} - The sort key, or an empty string if self is not a file.
    map.sortKey = function(self)
        if typeof(self) == "file" then
            return self.path.replace("[^a-zA-Z0-9]","")
        end if

        return ""
    end function

    // Returns a color-formatted version of a file's name based on its type and sensitivity.
    // Folders use s2, executables use l2, libraries use l3, sensitive text files use g1/o1,
    // and other source files use b1.
    // @return {string} - The color-formatted filename.
    map.getFileColor = function
        if typeof(self) != "file" then
            print(g.error("Invalid type: " + typeof(self)))
            return null
        end if

        names = ["Mail.txt","Bank.txt","Map.conf","sources.txt"]

        file = self

        if file.is_folder then return g.s2(file.name)

        if file.is_binary and not file.is_folder then
            if file.name[-3:] == ".so" then
                return g.l3(file.name)
            else
                return g.l2(file.name)
            end if
        end if

        if not file.is_binary then
            if file.name == "passwd" and file.path != "/bin/passwd" then
                if file.has_permission("r") then
                    return g.g1(file.name)
                else
                    return g.o1(file.name)
                end if
            else if names.indexOf(file.name) != null then
                if file.has_permission("r") then
                    return g.g1(file.name)
                else
                    return g.o1(file.name)
                end if
            else
                return g.b1(file.name)
            end if

        end if
    end function

    count = {"dirs": 0,"files": 0}

    // Credit for the pipe and line endings in the following three lines goes to Macha and Virus
    // I borrowed these from the Unity source code available here: https://github.com/MachaCeleste/CelestialCorp-Unity/
    continuedLine = "<size=120%><mspace=0.1> <mark=#ffffff>"+char(1564)+"</mark></size><mspace=-0.1>"+char(1564)+"</mspace></mspace> "
    line = "<size=120%><mspace=0.1> <mark=#ffffff>"+char(1564)+"</mark></size><#fff><s></mspace>  </s></color><space=0.3em><size=100%>"
    endLine = "<size=70%><mspace=0.1> <voffset=8><mark=#ffffff>"+char(1564)*2+"</mark></size><voffset=0><#fff><s></mspace>  </s></color><space=0.3em><size=100%>"

    // Recursively walks a directory, printing each entry with permissions, owner, group,
    // tree-drawing characters, and color-coded filename.
    // @param {file} directory - The folder to enumerate.
    // @param {string} prefix - The current tree-drawing prefix string (grows with depth).
    // @return {none}
    walk = function(directory, prefix)
        files = directory.get_folders + directory.get_files

        if files == [] then return

        temp = {}

        for file in files
            temp[file.name] = file
        end for

        indices = temp.indexes
        indices.sort

        files = []

        for index in indices
            files.push(temp[index])
        end for

        for index in range(0, files.len - 1)
            file = files[index]

            if index == files.len - 1 then
                parts = [endLine, "   "]
            else
                parts = [line, continuedLine + "  "]
            end if

            output = g.const.indent + "<size=120%>"
            output = output + file.permissions.formatPermissions + " "
            output = output + file.owner.formatUsername + "<pos=350>" + file.group.formatUsername + "<pos=500>"
            output = output + prefix + parts[0] + file.getFileColor

            print(output)

            if file.is_folder then
                count.dirs = count.dirs + 1
                walk(file, prefix + parts[1])
            else
                count.files = count.files + 1
            end if
        end for
    end function

    idx = g.context.index

    path = "/"

    if args != null and args.len > 0 then
        if args[0] == "help" or args[0] == "-h" or args.len > 1 then
            self.help
            return
        else if args[0] == "." then
            path = g.stack[idx].currentPath
        else
            if not g.stack[idx].file then
                print g.error("Current context does not have a file object available")
                return
            end if
            tempFile = g.stack[idx].file.getFolder(args[0])

            if typeof(tempFile) == "file" then
                path = tempFile.path
            else
                print(g.error("Could not find folder at path: " + args[0] + g.const.ni + g.r1("Setting path to ""/"".")))
            end if
        end if
    end if

    start = g.stack[idx].file.getFolder(path)

    output = g.const.indent + "<size=120%>"
    output = output + start.permissions.formatPermissions + " "
    output = output + start.owner.formatUsername + "<pos=350>" + start.group.formatUsername + "<pos=495>"
    output = output + "<color=#FFF>.</color>  " + start.getFileColor

    print(output)    

    walk(start, "")

    if count.dirs == 1 then
        totals = "1 directory, "
    else
        totals = count.dirs + " directories, "
    end if
    
    if count.files == 1 then
        totals = totals + "1 file"
    else
        totals = totals + count.files + " files"
    end if
    
    print g.const.ni + "<size=120%>" + g.l2(totals)
end function

// Fill out the parts of this template, and then place it in the a folder called 'tools' in the same directory as the main hex binary file.
// You can leave it as src code (name it with a .src file extension), otherwise hex will attempt to load it as a binary file that has been built with the
// 'allow import' flag set.

g.util.tree = {
    "name": "tree",
    "shortDescription": "Displays the file system contents in a tree view.",
    "exec": @tree,
    "help": @treeHelp,
    "data": {}
}