// Initialises the rshell subsystem.  When called with no index, reads the rshell server
// credentials from the "rshell" environment variable and connects via the current proxy or
// home shell, storing the result as a "rs server" context.  When an existing stack index
// is provided, promotes that context to the rshell server role without connecting.
// @param {string|null} idx - An existing shell stack index, or null to connect from env vars.
// @param {number} port - The default port for rshell clients (default: 1222).
// @return {number} - 1 if the server was set, 0 otherwise.
g.func.init_rshell = function(idx = null, port = 1222)
    if idx == null then
        temp = #envar rshell

        if temp == null or temp == "" then
            return 0
        end if

        rshell = g.func.deserialize(temp)

        if g.hasIndex("proxy") then
            context = g.stack[g.proxy]
        else
            context = g.stack["0"]
        end if

        if context.type != "shell" or not context.shell then
            print g.error("Invalid context type: " + context.type)
            return 0
        end if

        ip = rshell[0]
        port = rshell[1]
        user = rshell[2]
        pass = rshell[3]

        rshell = context.shell.connect_service(ip, 22, user, pass)

        if typeof(rshell) == "string" then
            print g.error(rshell)
            return 0
        end if

        if not rshell then
            print g.error("Failed to connect to rshell server at the following IP: " + ip)
            return 0
        end if

        rshellContext = rshell.createContext("rs server")
        rshellContext.path = "/root"

        key = g.stack.add(rshellContext)
    else
        if typeof(@idx) != "string" or (@idx).to_int == null or not g.stack.hasIndex(@idx) then
            print g.error("Invalid parameter: idx")
            return 0
        end if

        key = idx
        ip = g.stack[idx].public
        g.stack[idx].source = "rs server"
    end if

    if typeof(@port) == "string" and typeof(@port.to_int) == "number" then
        p = port.to_int
    else if typeof(port) == "number" then
        p = port
    else
        p = 1222
    end if

    g.rshell = { "key":key, "ip":ip, "port":p }
    return 1
end function

// Installs the rshell service on the shell context at the given stack index by uploading
// librshell.so, attaching it, and calling install_service.
// @param {string} idx - The stack index of the target shell context.
// @return {number} - 1 if installation succeeded, 0 otherwise.
g.func.install_rshell = function(idx)
    if not g.func.checkShell(idx) then return 0

    if not g.func.attach_rshell(idx) then return 0

    if not g.func.attach_metax(idx) then return 0

    print g.const.indent + g.s3("Installing librshell.so...")
    result = g.stack[idx].rshell.install_service

    if result isa string then
        print g.error(result)
        return 0
    end if

    return 1
end function

// Starts the rshell service on the context at the given index.  Installs librshell.so
// and metaxploit.so first if they are not already present.
// @param {string} idx - The stack index of the target shell context.
// @return {number} - 1 if the service started, 0 otherwise.
g.func.start_rshell = function(idx)
    if not g.func.checkShell(idx) then return 0

    if not g.stack[idx].rshell then
        file = g.stack[idx].computer.File("/lib/librshell.so")

        if not file then
            if not g.func.install_rshell(idx) then
                print g.error("Could not install rshell library")
                return 0
            end if
        else
            if not g.func.attach_rshell(idx) then return 0
        end if
    end if

    if not g.stack[idx].metax then
        if not g.func.attach_metax(idx) then return 0
    end if

    print g.const.indent + g.s3("Starting rshell service...")
    result = g.stack[idx].rshell.start_service

    if result isa string then
        print g.error(result)
        return 0
    end if

    return 1
end function

// Stops the rshell service on the context at the given index.
// @param {string} idx - The stack index of the target shell context.
// @return {number} - 1 if the service stopped, 0 otherwise.
g.func.stop_rshell = function(idx)
    if not g.func.checkShell(idx) then return 0

    if not g.stack[idx].rshell then
        print g.error("No attached rshell.")
        return 0
    end if

    result = g.stack[idx].rshell.stop_service

    if result == 1 then return 1

    if result == 0 then
        print g.error("Could not stop service")
    else if typeof(result) == "string" then
        print g.error(result)
    else
        print g.error("An unknown error occurred")
    end if

    return 0
end function

// Queries the rshell server at the given stack index for connected clients, adds each
// returned shell to the stack as an "rshell" context, and prints how many were found.
// @param {string} idx - The stack index of the rshell server context.
// @return {number} - 1 if rshells were retrieved, 0 otherwise.
g.func.get_rshells = function(idx)
    if not g.func.checkShell(idx) then return 0

    if not g.stack[idx].metax then
        print g.error("No metaxploit lib attached")
        return 0
    end if

    shells = g.stack[idx].metax.rshell_server

    if typeof(shells) == "string" then
        print g.error(shells)
        return 0
    end if

    for shell in shells
        rs = shell.createContext("rshell")
        g.stack.add(rs)
    end for

    print g.const.indent + g.s3("Added " + shells.len + " rshell(s) to the stack.")

    return 1
end function

// Kills all processes (except dsession, Xorg, kernel_task) on every "rshell" shell context
// currently in the stack.
// @return {none}
g.func.clear_rshells = function
    for key in g.stack.indexes
        if typeof(key.to_int) == "number" and g.stack[key].source == "rshell" and g.stack[key].type == "shell" then
            print "Removing: " + key
            g.func.remove_rshell(key)
        end if
    end for
end function

// Kills all non-essential processes on the rshell client at the given stack index.
// The context is not removed from the stack.
// @param {string} idx - The stack index of the rshell context to clean up.
// @return {number} - 1 if successful, 0 otherwise.
g.func.remove_rshell = function(idx)
    if not g.func.checkShell(idx) then return 0

    if g.stack[idx].source != "rshell" then
        print g.error("The specified context is not an rshell.")
        return 0
    end if

    user = g.stack[idx].user
    procs = g.stack[idx].computer.show_procs.split(char(10))[1:]

    for proc in procs
        usr = proc.split(" ")[0]
        pid = proc.split(" ")[1].to_int
        cmd = proc.split(" ")[4]

        if ["dsession", "kernel_task", "Xorg"].indexOf(cmd) == null then
            g.stack[idx].computer.close_program(pid)
        end if
    end for

    return 1
end function

// Prints the configured rshell server IP address and port from g.rshell.
// @return {number} - 1 if info was displayed, 0 if rshell is not configured.
g.func.rshell_info = function
    if not g.rshell or not g.rshell.ip or not g.rshell.port then
        print g.const.indent + g.o1("Rshell server ip and/or port are not set.")
        return 0
    end if

    print g.const.indent + g.o1("[rshell server info] IP: " + g.rshell.ip + " Port: " + g.rshell.port)

    return 1
end function

// Deploys an rshell client on the context at the given index, instructing it to connect
// back to the given IP and port under the specified process name.
// @param {string} idx - The stack index of the target shell context.
// @param {string} ip - The rshell server IP to call home to.
// @param {number} port - The rshell server port to call home to.
// @param {string} process - The process name for the client (default: "rshell_client").
// @return {number} - 1 if the client was deployed, 0 otherwise.
g.func.deploy_rshell = function(idx, ip, port, process = "rshell_client")
    if not g.func.checkShell(idx) then return 0

    if not g.stack[idx].metax then
        print g.error("No metaxploit library attached")
        return 0
    end if

    if typeof(@process) != "string" then process = "rshell_client"

    print g.const.indent + g.o1("[rshell client] IP: " + @ip + " Port: " + @port + " Process Name: " + process)
    result = g.stack[idx].metax.rshell_client(@ip, @port, process)

    if typeof(result) == "string" then
        print g.error(result)
        return 0
    end if

    return 1
end function

// Validates that g.rshell is fully configured with a valid IP, port, and stack index.
// @return {number} - 1 if the rshell configuration is valid, 0 otherwise.
g.func.check_rshell = function
    if not g.hasIndex("rshell") then
        print g.error("rshell server not set")
        return 0
    end if
    if not g.rshell.hasIndex("ip") or typeof(g.rshell.ip) != "string" or not is_valid_ip(g.rshell.ip) then
        print g.error("Invalid rshell server ip")
        return 0
    end if
    if not g.rshell.hasIndex("port") or typeof(g.rshell.port) != "number" or g.rshell.port < 1 or g.rshell.port > 65535 then
        print g.error("Invalid rshell server port")
        return 0
    end if
    if not g.rshell.hasIndex("key") or typeof(g.rshell.key) != "string" or typeof(g.rshell.key.to_int) != "number" then
        print g.error("Invalid rshell server stack index")
        return 0
    end if

    return 1
end function